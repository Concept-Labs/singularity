# Singularity DI Next-Gen PSR-11 Container
Ядро екосистеми Concept

## Огляд

`Singularity DI` – це сумісний зі стандартом `PSR-11` контейнер залежностей нового покоління, що керує створенням сервісів з урахуванням контексту їх використання. Він виступає ядром екосистеми Concept Labs, забезпечуючи гнучке та розширюване налаштування впровадження залежностей. `Singularity DI` не обмежується статичними фабриками або простим зберіганням об’єктів – він динамічно визначає, який саме клас реалізації потрібен для даного інтерфейсу або сервісу, спираючись на конфігураційне дерево, механізми рефлексії та систему плагінів.

### Ключові можливості `Singularity DI`:

- **Відповідність PSR-11 + розширення**: Реалізує інтерфейс Psr\Container\ContainerInterface (методи get(), has()) та надає додатковий метод create() для явного створення нового екземпляра сервісу (ігноруючи кешування).

- **Контекстуальне впровадження залежностей**: Дозволяє призначати різні реалізації для одного інтерфейсу залежно від контексту – глобально, для певного простору імен або навіть для конкретного сервісу. Конфігурація об’єднує прив’язки (`bindings`) із кількох рівнів, що дає змогу гнучко переналаштовувати поведінку контейнера без змін у коді.

- **Автовпровадження (`autowiring`)**: Якщо ідентифікатор запитаного сервісу не налаштований у конфігурації, контейнер припускає, що це ім'я класу, і спробує автоматично створити його, розв’язавши залежності через рефлексію. Якщо клас не існує або не може бути створений – генерується виняток.

- **Плагінна система**: Під час створення кожного сервісу контейнер може виконувати додаткові дії через плагіни. Плагіни можуть підключатися як до створення об’єкта, так і після нього – це дозволяє реалізувати перехоплення, логування, обгортання об’єктів (наприклад, у проксі) та інші крос-різальні функціональні можливості без змін логіки сервісів. Набори плагінів налаштовуються глобально або для конкретного сервісу.

- **Управління життєвим циклом сервісів**: `Singularity DI` за замовчуванням кешує створені об’єкти в реєстрі сервісів, щоб повторно використовувати їх (патерн Singleton за замовчуванням). Водночас, щоб уникнути витоків пам’яті, контейнер може зберігати посилання на об’єкти як «слабкі» (`WeakReference`) – якщо більше ніде немає посилань на сервіс, сміттєзбирач PHP зможе його знищити. Контейнер також підтримує неоднократні (`prototype`) сервіси: якщо клас реалізує інтерфейс PrototypeInterface, один закешований екземпляр слугуватиме прототипом, і при кожному запиті через `get()` контейнер повертатиме новий об’єкт, викликаючи його метод `prototype()`.

- **Інтеграція з конфігурацією**: Контейнер щільно інтегрований з пакетом конфігурації [Concept-Labs/Config](http://), що дозволяє автоматично збирати налаштування з `Composer`-пакетів. Конфігурація описує прив’язки інтерфейсів до реалізацій, налаштування плагінів та інші параметри DI в форматі (JSON або PHP-масив). Завдяки цьому можлива автоматична реєстрація сервісів та пакетів (`auto-discovery`) в масштабних додатках.

- **Як результат, `Singularity DI` набагато потужніший за мінімальний `PSR-11` контейнер. Він не просто зберігає фабрики або готові об’єкти, а здатен динамічно вирішувати, як створити сервіс в конкретному випадку, використовуючи гнучкі правила конфігурації та розширювану систему плагінів. Усе це дозволяє налаштовувати поведінку контейнера через зовнішні описання (конфігурацію або PHP-атрибути) без внесення змін до коду самих класів сервісів**.

## Основні компоненти архітектури

`Singularity DI` побудований за модульним принципом. Нижче розглянуті основні компоненти, що забезпечують його роботу:

### Контейнер Singularity

- Головний клас `Singularity` реалізує інтерфейс `PSR-11` `ContainerInterface` і розширює його можливості. Саме він є точкою входу для отримання сервісів. Основні методи контейнера:

- `get(string $id)` – повертає instanced сервісу за ідентифікатором (назва класу або інтерфейсу). Якщо сервіс уже створений і кешований, поверне цей екземпляр; якщо ні – контейнер ініціалізує новий.

- `has(string $id)` – перевіряє наявність налаштувань або вже створеного сервісу за даним ідентифікатором.

- `create(string $id, array $overrideArgs = [], array $depStack = [])` – розширення `PSR-11`: примусово створює новий екземпляр сервісу, ігноруючи можливий кеш. Корисно для об’єктів, які потрібно мати у кількох копіях одночасно або для яких потрібен свіжий стан.

При створенні контейнера (`new Singularity($config)`), йому передається об’єкт конфігурації (зібраний з використанням [Concept-Labs/Config](http://)). В процесі ініціалізації контейнер:

- завантажує всі налаштування `DI` (вузол конфігурації "`singularity`"),

- налаштовує глобальні плагіни згідно з конфігурацією,

- готує реєстр сервісів та збирач контексту для подальшої роботи.

Викликаючи `get()` або `create()`, контейнер виконує комплекс дій:

- Формує контекст для запитуваного сервісу через `ContextBuilder` (_див. нижче_), визначаючи, який клас і з якими залежностями потрібно створити.

- Перед створенням об’єкта викликає методи `before()` усіх зареєстрованих плагінів (через `PluginManager`) – плагіни можуть підготувати чи змінити контекст.

- Інстанціює об’єкт потрібного класу (через рефлексію, автозаповнення залежностей або виклик фабрики).

- Після створення викликає методи `after()` плагінів – вони отримують доступ до новоствореного об’єкта і можуть виконати додаткову ініціалізацію, обгорнути об’єкт, зареєструвати його тощо.

- Кешує об’єкт у реєстрі сервісів (якщо це `shared` сервіс) і повертає його.

### Реєстр сервісів (`ServiceRegistry`)

`ServiceRegistry` відповідає за зберігання вже створених екземплярів сервісів і керування їх повторним використанням. Кожен створений сервіс реєструється під своїм ідентифікатором (ключем):


- За замовчуванням сервіси НЕ зберігаються в реєстрі
    - Для збереження в реєстрі сервіс має імплементувати вбудований контракт (`Concept\Singularity\Plugin\ContractEnforce\Lifecycle\SharedInterface`). В цьому випадку спрацює плагін `SharedPlugin` та збереже сервіс у реєстрі сервісів.
- За замовчуванням `Shared` сервіси зберігаються як звичайні посилання, тож повторний виклик `get()` поверне той самий об’єкт ( `singleton behavior` ).

- За бажанням, реєстр може зберігати «слабкі» посилання на об’єкти за допомогою `WeakReference`. Якщо сервіс зареєстровано як слабкий (для цього сервіс має імплементувати вбудований контракт `Concept\Singularity\Plugin\ContractEnforce\Lifecycle\Shared\WeakInterface`, або в конфігурації `preference` для сервісу явно включений `SharedPlugin` з параметром "`weak": true` ), контейнер не перешкоджатиме його видаленню збирачем сміття. Тобто, коли на об’єкт більше не лишилося сильних посилань у коді, PHP автоматично вивільнить пам’ять, а при наступному запиті контейнер створить новий екземпляр. Така можливість особливо корисна для довготривалих процесів або коли деякі сервіси використовуються рідко – це запобігає витокам пам’яті.

Окрім того, реєстр має спеціальну обробку для прототипних сервісів. Якщо об’єкт реалізує інтерфейс `PrototypeInterface`, контейнер розуміє, що цей сервіс не потрібно створювати заново при кожному запиті а розробник передбачить виконання сервісом контракту у вигляді методу `prototype()`. Алгоритм такий: один екземпляр все ж створюється і кешується, але далі, при кожному `get()`, контейнер не віддає його напряму, а викликає метод прототипу (наприклад, `prototype()`), отримуючи копію або новий стан об’єкта. Таким чином, один закешований об’єкт слугує шаблоном для створення інших. Цей прийом дозволяє, з одного боку, зберегти відому точку доступу до сервісу, а з іншого – не ділитися з різними споживачами тим самим екземпляром.

## Збирач контексту (`ContextBuilder`)

`ContextBuilder` будує контекст залежності для сервісу на основі його запиту та глобальної конфігурації. Кінцевою метою є сформувати прото-контекст – спеціальний об’єкт з усією мета-інформацією, необхідною для створення сервісу.

При запиті сервісу, `ContextBuilder` виконує наступне:

- Аналізує запитаний ідентифікатор (інтерфейс, абстрактний чи конкретний клас) та визначає, до якого простору імен та пакету він належить (використовуючи дані конфігурації про пакети і неймспейси).

- Послідовно об’єднує налаштування прив’язок (`preferences`) з кількох рівнів конфігурації: спочатку пакетного, потім рівня простору імен, і нарешті глобального. На кожному рівні можуть бути визначені відповідності між абстракцією та конкретним класом, а також параметри створення. Якщо для даного сервісу є спеціальні локальні налаштування – вони мають найвищий пріоритет.

- На основі зібраних налаштувань визначає фінальний клас, який слід інстанціювати для цього сервісу (поле `serviceClass`), а також збирає інформацію про бажані аргументи конструктора, специфічні для сервісу плагіни, тощо.

## Ієрархія налаштувань (`preferences`), що об’єднує `ContextBuilder`:

- **Пакетні налаштування** – задаються самим пакетом, до якого належить сервіс (як правило, у файлі `concept.json` цього пакета). Тут можуть бути визначені типові реалізації інтерфейсів, які надає пакет, а також залежності від інших пакетів. Приклад: пакет `Singularity` у своєму `concept.json` декларує, що інтерфейс контейнера `Psr\Container\ContainerInterface` та власний інтерфейс `SingularityInterface` мають впроваджуватися класом `Concept\Singularity\Singularity`.

- **Налаштування простору імен** – глобальна конфігурація може містити вузол `namespace`, де для певного простору імен указано свої перевизначення. Якщо запитуваний сервіс належить до такого неймспейсу, застосовуються ці правила. Це дозволяє задати для всіх сервісів в межах певного модуля інші реалізації залежностей, ніж типові пакетні.

- **Глобальні (локальні) прив’язки сервісу** – у вузлі `singularity.preference` конфігурації додатка можна задати конкретну реалізацію саме для цього ідентифікатора. Ці налаштування мають найвищий пріоритет і перекривають всі інші. Тут же можна вказати додаткові аргументи конструктора, спеціальні плагіни чи посилання на попередньо визначений референс конфігурації.

Якщо після врахування всіх рівнів не знайдено жодного співставлення для сервісу (тобто сервіс не сконфігурований ніде), `Singularity` помічає його як `unresolved`. В такому випадку контейнер трактує ідентифікатор як ім’я класу і намагається створити об’єкт цього класу напряму, застосовуючи автовпровадження. Завдяки цьому можна отримувати з контейнера навіть ті класи, що не внесені у конфігурацію, якщо їхні залежності можна визначити автоматично. Якщо ж класу з таким ім’ям не існує або його неможливо створити – буде кинуто виняток `ServiceNotFoundException`.

## Прото-контекст сервісу (`ProtoContext`)

`ProtoContext` – це структура даних, що інкапсулює всі деталі про сервіс, який слід створити. Вона включає:

- унікальний `ID` сервісу (з яким був зроблений запит до контейнера),

- визначений клас для інстанціювання (`serviceClass`),

- стек залежностей – ланцюжок сервісів, через які контейнер прийшов до цього (корисно для відстеження циклічних залежностей та розуміння контексту),

- конфігурацію для сервісу: вказані аргументи конструктора, прив’язані плагіни, режим кешування тощо.

`ProtoContext` тісно пов’язаний з механізмом рефлексії: при першому створенні він ініціалізує та кешує `ReflectionClass` для цільового класу, отримує список параметрів конструктора, а також читає атрибути PHP (якщо вони присутні на класі або його конструкторі). Атрибути можуть використовуватися для додаткових DI-налаштувань – наприклад, щоби зазначити, що для цього сервісу потрібні певні плагіни або особливий спосіб створення.

На основі всієї цієї інформації `ProtoContext` допомагає контейнеру вирішити, як саме створити об’єкт:

- який фабричний метод використати (звичайний конструктор чи спеціальна фабрика),

- які аргументи передати в конструктор (можливо, частину отримати як сервіси з контейнера, частину з конфігураційних значень),

- які плагіни потрібно застосувати до чи після створення,

- чи слід кешувати отриманий екземпляр, чи реєструвати його як слабке посилання, чи не зберігати взагалі (для суто прототипних або ephemeral об’єктів).

## Плагінова система

`Singularity DI` має вбудовану плагінову систему, яка дає змогу розширювати поведінку контейнера при створенні сервісів. Плагіни можуть виконувати додаткові дії до створення об’єкта сервісу або після цього, інтегруючись у життєвий цикл `get()` запиту. Це дозволяє реалізувати такі можливості, як: одиночність або прототипність сервісів (`singleton/prototype`), автовиклик методів ініціалізації, підтримка PHP-атрибутів для впровадження залежностей, ліниве створення об’єктів тощо – без зміни основної логіки контейнера. Нижче детально розглянемо інтерфейс плагінів, механіку їх підключення та використання, а також наявні “з коробки” плагіни `Singularity DI`.

Інтерфейс `PluginInterface`

Кожен плагін у `Singularity DI` реалізує інтерфейс `PluginInterface`. Він визначає два статичних методи – `before(...)` і `after(...)`, які виконуються відповідно до створення сервісу і після створення сервісу. 

Сигнатура інтерфейсу наступна:
```php
interface PluginInterface 
{
    const BEFORE = 'before';
    const AFTER = 'after';

    public static function before(\Concept\Singularity\Context\ProtoContextInterface $context, mixed $args = null): void;

    public static function after(object $service, \Concept\Singularity\Context\ProtoContextInterface $context, mixed $args = null): void;
}
```


Метод `before(...)` отримує контекст створення сервісу (об’єкт, що реалізує `ProtoContextInterface`) та опціональні аргументи, і виконується перед тим, як контейнер почне безпосередньо створювати об’єкт. Метод `after(...)`, натомість, викликається після того, як об’єкт сервісу вже створений; він отримує цей створений об’єкт та той самий контекст. Обидва методи є статичними, оскільки плагіни в `Singularity DI` не потребують зберігати стан між викликами – кожен виклик здійснюється з усією необхідною інформацією через параметри.

`ProtoContextInterface` – це інтерфейс, що представляє контекст поточного запиту сервісу. Через об’єкт контексту плагін може дізнатися:

- `ID` сервісу, який запитується (`getServiceId()`),

- Повністю визначений клас, який буде створюватися (`getServiceClass()` – з урахуванням preference та інших налаштувань контейнера),

- Відображення для рефлексії (`getReflection()` – об’єкт `ReflectionClass` для сервісу),

- Аргументи, передані до контейнера для створення (якщо були),

- Контейнер, що створює сервіс (`getContainer()`),

- А також іншу інформацію (наприклад, стек залежностей для відслідковування циклічних посилань, тощо).

Інтерфейс `PluginInterface` надає базовий контракт. Для спрощення розробки плагінів у `Singularity DI` передбачено абстрактний клас `AbstractPlugin`, який вже реалізує цей інтерфейс (пустими методами). Створюючи новий плагін, можна успадкуватися від `AbstractPlugin` і перевизначити лише ті методи (`before` або `after`), які необхідно реалізувати. Це позбавляє від потреби оголошувати обидва методи, якщо, наприклад, плагін має дію тільки «після» створення сервісу.

### Інтеграція плагінів у процес створення сервісів

Плагіни інтегруються в роботу контейнера через спеціальний менеджер плагінів. `Plugin Manager` збирає зареєстровані плагіни та викликає їхні методи `before/after` у потрібний момент. Коли ви викликаєте `$container->get(<ServiceId>)`, `Singularity DI` виконує наступне:

- **Before-phase**: Безпосередньо перед створенням нового об’єкта контейнер викликає `PluginManager->before($context, PluginInterface::class)`. Менеджер плагінів проходить по всіх зареєстрованих плагінах і викликає їх статичні методи `before($context, $args)`. Таким чином, всі підключені плагіни мають шанс втрутитися в процес до того, як об’єкт буде побудовано. Плагін може проаналізувати запит (контекст) і, за потреби, внести корективи. Наприклад, `FactoryPlugin` на цьому етапі може замінити фабрику створення сервісу (про це нижче), або плагін може змінити деякі аргументи контексту, увімкнути/вимкнути інші плагіни для цього сервісу тощо.

- Створення сервісу: Після виклику `before`-методів контейнер продовжує стандартне створення сервісу. Зазвичай, якщо фабрику не було змінено плагінами, `Singularity DI` просто викликає конструктор класу (`new <ServiceClass>(...)`) з усіма зібраними залежностями. (В процесі резолвінгу залежностей можуть рекурсивно викликатися `get()` для інших сервісів, які, у свою чергу, також пройдуть через плагіни – це забезпечує єдиний механізм для всіх рівнів залежностей).

- **After-phase**: Одразу після того, як об’єкт сервісу створено, контейнер викликає `PluginManager->after($service, $context, PluginInterface::class)`. Менеджер плагінів знов проходиться по всіх плагінах і викликає їх `after($service, $context, $args)`. На цьому етапі плагіни можуть виконувати пост-обробку об’єкта – наприклад, здійснити додаткову ініціалізацію, зареєструвати об’єкт для подальшого повторного використання, обгорнути його проксі-об’єктом для лінивого завантаження, або викликати якісь методи життєвого циклу сервісу.

Важливо, що послідовність виконання плагінів може бути налаштована. Кожен плагін при реєстрації отримує пріоритет (за замовчуванням всі плагіни можуть мати пріоритет 0, або ви можете задати інше значення). `Plugin Manager` впорядковує виклик `before/after` відповідно до пріоритетів: плагіни з меншим значенням пріоритету виконуються раніше, з більшим – пізніше. Це дозволяє тонко налаштувати, в якій послідовності різні плагіни будуть впливати на процес створення сервісу.

### Налаштування та підключення плагінів

За замовчуванням `Singularity DI` має набір вбудованих плагінів (про них далі), але ви можете додавати власні плагіни. Реєстрація плагіна зазвичай здійснюється через конфігурацію. У конфігурації передбачений вузол `singularity.settings.plugin-manager.plugins`, де можна перелічити додаткові плагіни. Наприклад:

```json
"singularity": {
  "settings": {
    "plugin-manager": {
      "plugins": {
          "MyApp\\DI\\Plugin\\LoggingPlugin": {}
          "Another\\Plugin\\CustomPlugin": { 
            "priority": 10,
            "option": true 
            },
            "Third\\Plugin\\NoneedPlugin": false
      }
    }
  }
}
```

У такому прикладі налаштовано два плагіни:

- `MyApp\DI\Plugin\LoggingPlugin` з пріоритетом 0 (виконуватиметься першим). Не містить додаткових параментрів.
- `Another\Plugin\CustomPlugin` з пріоритетом 10 (виконуватиметься після `LoggingPlugin`). Для нього передано приклад додаткової опції option: true (у загальному випадку, args — це масив або скаляр, який буде другим параметром у методах `before/after` плагіна).

#### Також є можливість налаштування плагінів через preference конфігурацію для окремого сервісу
```json
...
    "preference": {
        "Acme\\App\\SomeService": {
            ...
            "plugins": {
                "My\\Cusom\\Plugin": {},
                "MyApp\\DI\\Plugin\\LoggingPlugin"
            }
        }
    }
```

В цьому випадку до процесу створення сервісу `Acme\App\SomeService` було додано `My\Cusom\Plugin` а також "відключено" раніше сконфігурований ukj,fkmybq плагін `MyApp\DI\Plugin\LoggingPlugin`.

>Примітка: Якщо кілька плагінів мають однаковий пріоритет, їх порядок визначається або додатковою логікою менеджера, або вони можуть виконуватись у довільному порядку – тому пріоритети бажано робити унікальними, відступаючи між ними (наприклад, 0, 10, 20, ...), щоб було легше вставляти нові.

Коли конфігурація застосовується до контейнера (це відбувається при ініціалізації Singularity через метод ->setConfig(...)), менеджер плагінів зчитує цей список і реєструє відповідні плагін-класи. Після цього вони автоматично починають брати участь у життєвому циклі створення сервісів.

### Створення власного плагіну (приклад)

Розглянемо простий приклад створення користувацького плагіну. Припустимо, ми хочемо логувати інформацію про кожен створюваний сервіс. Для цього створимо плагін `LoggingPlugin`, який перед створенням і після створення сервісу записує повідомлення в лог.
```php
namespace MyApp\DI\Plugin;

use Concept\Singularity\Plugin\AbstractPlugin;
use Concept\Singularity\Context\ProtoContextInterface;

class LoggingPlugin extends AbstractPlugin 
{
    public static function before(ProtoContextInterface $context, mixed $args = null): void
    {
        $serviceId = $context->getServiceId();
        error_log("[Singularity] Creating service: $serviceId");
    }

    public static function after(object $service, ProtoContextInterface $context, mixed $args = null): void
    {
        $serviceClass = get_class($service);
        error_log("[Singularity] Service created: $serviceClass");
    }
}
```

Кілька пояснень до цього прикладу:

- Ми успадкували `LoggingPlugin` від `AbstractPlugin`, щоб не прописувати методи, які не використовуємо (в даному випадку ми реалізуємо і `before`, і `after`, але якби, наприклад, нам потрібен був тільки метод `after`, `before` можна було б не перевизначати – успадкований пустий метод просто нічого не робив би).

- У методі `before` ми отримуємо `ID` сервісу, який буде створюватися, через `$context->getServiceId()` і логуємо це. (ID може бути ім’ям класу або аліасом, залежно від того, що передавалося в `->get()`).

- У методі `after` ми отримуємо вже створений об’єкт `$service` і визначаємо його клас, щоб залогувати повідомлення про успішне створення. Тут також можна отримати `ID` або інші деталі з `$context` при потребі.

Після написання такого класу, слід додати його до конфігурації (як показано вище) в список плагінів. 

Наприклад:
```json
"singularity": {
  "settings": {
    "plugin-manager": {
      "plugins": {
          "MyApp\\DI\\Plugin\\LoggingPlugin": {}
      }
    }
  }
}
```


Тепер `Singularity DI` при кожному створенні будь-якого сервісу буде викликати наш `LoggingPlugin`, і в логах з’являтимуться записи про те, які сервіси створюються.

Звісно, цей приклад доволі простий. За допомогою плагінів можна робити і складніші речі – наприклад, умовно включати/виключати інші плагіни, модифікувати способи створення сервісів, або навіть повністю перехоплювати створення певних об’єктів. Головне – пам’ятати, що плагіни не повинні зловживати своїми можливостями (наприклад, не варто в плагіні без потреби викликати створення інших сервісів, щоб не виникало непередбачуваних залежностей). Але в цілому, плагінова система – потужний інструмент для розширення функціональності DI-контейнера.

### Вбудовані плагіни `Singularity DI`

З коробки `Singularity DI` постачається з декількома стандартними плагінами, які забезпечують базові можливості контейнера. Нижче перелік основних плагінів та опис їх функцій:

- `SharedPlugin` (плагін управління спільними сервісами): Забезпечує `singleton`-поведінку за замовчуванням. Коли сервіс створюється, цей плагін (через свою реалізацію `after`) автоматично реєструє створений об’єкт в контейнері, щоб при наступних запитах того самого сервісу повертати вже існуючий екземпляр замість створення нового. Іншими словами, якщо сервіс позначений як «shared», то після першого створення він зберігається і повторно використовується. У конфігурації можна явно керувати цим: наприклад, встановивши для конкретного binding параметр "shared": true, можна включити кешування, і тоді `Singularity DI` зареєструє об’єкт не зважаючи на контракти. Також підтримується режим `weak` для спільних сервісів (наприклад, зберігання слабких посилань замість прямих, щоб уникнути витоку пам’яті у певних сценаріях), який теж налаштовується через параметри. Плагін `Shared` гарантує, що якщо сервіс має бути єдиним, у контейнері він теж буде єдиним.

- `PrototypePlugin` (плагін управління прототипами): Доповнює `SharedPlugin`, забезпечуючи `prototype`-поведінку сервісів, які цього потребують. Якщо сервіс позначено як прототипний (на відміну від `singleton`), контейнер має створювати новий екземпляр при кожному запиті. В `Singularity DI` це реалізовано через контракт `PrototypeInterface`. Якщо клас сервісу реалізує `Concept\Singularity\Contract\Lifecycle\PrototypeInterface`, він повинен надати метод `prototype()`, який повертає новий екземпляр (наприклад, клон або новостворений об’єкт). `PrototypePlugin` після створення об’єкта перевіряє, чи він реалізує `PrototypeInterface`. Якщо так – контейнер зберігає його як `shared`, а при наступних зверненнях може викликати метод `prototype()` для отримання копії. Якщо ж сервіс очікувався як прототипний (наприклад, у конфігурації для нього стоїть "shared": false або інший сигнал), а клас не реалізує потрібний інтерфейс, плагін може кинути виняток, сигналізуючи про порушення контракту. Таким чином, `PrototypePlugin` забезпечує, що сервіси, які повинні бути множинними, не кешуються і, за можливості, надають нові екземпляри оптимальним шляхом.

- `AttributePlugin` (плагін підтримки атрибутів): Включає механізми для роботи з PHP-атрибутами у контексті DI. Він дозволяє налаштовувати поведінку для окремих класів через PHP 8 атрибути. Зокрема, `Singularity DI` має вбудовані атрибути `#[\Concept\Singularity\Plugin\Attribute\Plugin]` та `#[\Concept\Singularity\Plugin\Attribute\Injector]`. Як це працює: якщо клас сервісу позначений атрибутом `#[Plugin(SomePlugin::class, args)]`, `AttributePlugin` при створенні такого сервісу викличе додатковий плагін `SomePlugin` тільки для цього класу. Це дає змогу “прикріпити” певний плагін до конкретного сервісу через анотацію в коді, навіть не додаючи його глобально в `Plugin Manager`. Наприклад, ви можете помітити якийсь клас атрибутом, що вказує на плагін логування або спеціальної ініціалізації – і цей плагін буде виконано тільки для цього сервісу. Атрибут `Injector` використовується для позначення методів, які потрібно викликати для впровадження залежностей після створення об’єкта (щось подібне до post-construct методів) "прапорцем" для використання плагіну `#Injector` для методу є імплементація класом контракту `InjectableInterface`. Плагін `Attribute` сканує клас та його методи на наявність таких атрибутів і відповідним чином реагує: викликає зазначені методи, або підключає зазначені в атрибутах плагіни в процес `before/after` саме для цього об’єкта. Таким чином, `AttributePlugin` забезпечує гнучку, декларативну конфігурацію `DI` прямо в коді класів за допомогою сучасного механізму атрибутів PHP.

- `FactoryPlugin` (плагін фабрик/ліниве завантаження): Дозволяє тонко налаштувати, як створюється об’єкт сервісу. У стандартному режимі контейнер просто викликає конструктор класу. `FactoryPlugin` же може перехопити цей момент (на фазі `before`) і встановити для поточного контексту спеціальну фабрику створення. Наприклад, є два типових сценарії:

    - `Lazy Initialization` (ліниве створення): Клас може реалізовувати певний інтерфейс або бути проксі-обгорткою, яка відкладає створення “важкого” об’єкта до першого виклику методу. `FactoryPlugin` може виявити, що запитуваний сервіс – це `lazy proxy` (приміром, клас, який має в назві Lazy або реалізує спеціальний інтерфейс наприклад вбудований `Concept\Singularity\Plugin\ContractEnforce\Factory\LazyGhost`), і замість створення реального об’єкта одразу, підставити фабрику, яка при першому зверненні виконає фактичне створення. Таким чином контейнер поверне легку обгортку, а важкий об’єкт створиться тільки при потребі.

    >`TODO`: Custom Factory: Іноді буває, що об’єкт потрібно створити не через прямий виклик конструктора, а через фабричний метод або фабричний сервіс. `FactoryPlugin` може надати підтримку такого патерну. Наприклад, якщо в конфігурації для сервісу вказано не ключ "class", а щось на кшталт "factory": [<FactoryClass>, "<method>"], плагін Factory може перехопити before і встановити фабрику, яка викличе цей метод фабрики для отримання об’єкта.

Реалізацій `FactoryPlugin` у `Singularity DI` декілька: є, зокрема, підплагіни `LazyGhost` і `NewInstance`, які відповідають за різні аспекти. Але з точки зору користувача контейнера важливо розуміти загальне: `FactoryPlugin` дає можливість змінити спосіб створення об’єкта. У більшості випадків вам не треба безпосередньо налаштовувати цей плагін – він працює автоматично, реагуючи на певні шаблони конфігурації або інтерфейси. Але знання про нього допоможе зрозуміти, як реалізовані ліниві сервіси чи альтернативні способи інстанціювання об’єктів у контейнері.

### `Singlarity DI` має набір вбудованих контрактів що забезпечують обробку сервісу відповідними плагінами
Так звані Enforcement контракти, для яких передбачений окремий плагін `Enforcement` що групує в собі стек плагінів:
> набір буде розширюватись
- **Factory** контраки
    - `Concept\Singularity\Plugin\ContractEnforce\Factory\LazyGhostInterface` встановлую в протоконтексті екземпляр фабрики який створює сервіс у вигляді LazyGhost
- **Initialization** контракти
    - `Concept\Singularity\Contract\Initialization\InjectableInterface` дозволяє застосовувати до методів атрибут `#[Injector]`.
    Метод позначений атрибутом `#[Injector]` буде визваний після створення сервісу а його аргументи будуть розцінюватись як `Dependency Injection` по прикладу як в конструкторі.
    - `Concept\Singularity\Contract\Initialization\AutoConfigureInterface` контракт зобов'язує сервіс реалізувати метод `public function autoConfigure(ConfigInterface $config): void;`. Тоді на основі вмісту конфігураційної ноди `preference` сервісу буде створений екземпляр `Concept\Config\Config` та переданий в якості аргументу.
- **Lifecycle** котракти:
    - `Concept\Singularity\Contract\Lifecycle\SharedInterface` забезпечує зберігання новоствореного сервісу в `Service Registry` (`singleton`)
        - підконтракт `Concept\Singularity\Contract\Lifecycle\Shared\WeakInterface` забезпечує зберігання shared сервісу у вигляді `WeakReference`
    - `Concept\Singularity\Contract\Lifecycle\PrototypeInterface` схожий на Shared але розширено зобов'язує реалізувати метод `prototype()`. Наприклад може повернути очищений клое сервісу або зі зміненим статусом тощо.
> планується розширення стеку вбудованих enforcement котрактів та плагінів



Завдяки плагіновій системі, контейнер Singularity залишається легким у використанні для базових випадків, але надзвичайно гнучким для розширених сценаріїв. Ви можете додавати свої плагіни для нових видів поведінки або використовувати наявні, майже не втручаючись у основний код вашого додатку – достатньо налаштувати конфігурацію або анотації. Докладніше про розширення Singularity і розробку власних плагінів ви можете дізнатися з прикладів та вихідного коду, але сподіваємося, що цей огляд дав чітке розуміння ключових можливостей. Вдалого використання Singularity DI!

## Базовий приклад

Розглянемо високорівневий приклад конфігурації і коду, щоб познайомитися з принципами роботи `Singularity DI`. Нехай ми маємо Composer-пакет `foo/lifestyle`, який визначає певні інтерфейси та класи:

Інтерфейс поїздки `TripInterface` і абстрактний базовий клас `AbstractTrip`, що реалізує цей інтерфейс. Поїздка потребує автомобіль, тому в конструкторі `AbstractTrip` ми очікуємо залежність типу `CarInterface`.

Дві реалізації поїздки: `Weekend\Trip` (для поїздки вихідного дня) та, припустимо, `Workday\Trip` (для робочого дня). Обидва наслідують `AbstractTrip`.

Інтерфейс автомобіля `CarInterface` і дві його реалізації: `BMW` та `Audi` (наприклад, різні моделі авто).

Спочатку налаштуємо контейнер так, щоб за замовчуванням використовувалася машина `BMW` для будь-якої поїздки. Для цього у конфігурації прив’яжемо `CarInterface` до класу `BMW`, а інтерфейс `TripInterface` – до конкретної реалізації `Weekend\Trip` (для спрощення припустимо, що будемо використовувати саме `weekend-trip` як типову поїздку):

`composer.json (фрагмент)`
```json
{
    "name": "foo/lifestyle",
    "...": "...",
    "extra": {
        "concept": {}  // Для екосистеми Concept-Labs: увімкнути auto-discovery (можливі майбутні опції)
    }
}
```json

`Foo\Lifestyle\TripInterface.php`
```php
namespace Foo\Lifestyle;

interface TripInterface
{
    public function getCar(): CarInterface;
}
```

`Foo\Lifestyle\AbstractTrip.php`
```php
namespace Foo\Lifestyle;

abstract class AbstractTrip implements TripInterface
{
    public function __construct(private CarInterface $car) {}

    public function getCar(): CarInterface
    {
        return $this->car;
    }
}
```

`Foo\Lifestyle\Weekend\Trip.php`
```php
namespace Foo\Lifestyle\Weekend;

class Trip extends \Foo\Lifestyle\AbstractTrip
{
    // Можна додати власні властивості чи методи, специфічні для поїздки вихідного дня
}
```

`Foo\Lifestyle\Garage\CarInterface.php`
```php
namespace Foo\Lifestyle\Garage;

interface CarInterface
{
    public function getModel(): string;
}
```

`Foo\Lifestyle\Garage\BMW.php`
```php
namespace Foo\Lifestyle\Garage;

class BMW implements CarInterface
{
    public function getModel(): string 
    { 
        return 'BMW'; 
    }
}
```

`Foo\Lifestyle\Garage\Audi.php`

```php
namespace Foo\Lifestyle\Garage;

class Audi implements CarInterface
{
    public function getModel(): string 
    { 
        return 'Audi'; 
    }
}
```

Конфігурація (наприклад, у файлі `concept.json` цього пакету або в глобальному конфігу додатка):
```json
"singularity": {
    "preference": {
        "Foo\\Lifestyle\\TripInterface": {
            "class": "Foo\\Lifestyle\\Weekend\\Trip"
        },
        "Foo\\Lifestyle\\Garage\\CarInterface": {
            "class": "Foo\\Lifestyle\\Garage\\BMW"
        }
    }
}
```


Така конфігурація вказує контейнеру, що коли хтось запросить сервіс за інтерфейсом `TripInterface`, слід створити об’єкт класу `Foo\Lifestyle\Weekend\Trip`. А для залежності `CarInterface` слід використати реалізацію `Foo\Lifestyle\Garage\BMW`.

Тепер використаємо контейнер `Singularity Di` (припустимо, змінна `$singularity` містить вже створений і налаштований контейнер) для отримання сервісів:
```php
/** @var Foo\Lifestyle\TripInterface $trip */
$trip = $singularity->get(Foo\Lifestyle\TripInterface::class);

/** @var Foo\Lifestyle\Garage\CarInterface $car */
$car = $trip->getCar();                // Отримуємо залежність, впроваджену в Trip (BMW за замовчуванням)
$model = $car->getModel();             // "BMW"
```

У наведеному прикладі виклик `$singularity->get(Foo\Lifestyle\TripInterface::class)` поверне екземпляр `Foo\Lifestyle\Weekend\Trip`. Контейнер побачить, що TripInterface прив’язаний до класу `Weekend\Trip` і створить відповідний об’єкт. Під час його створення `Singularity DI` автоматично знайде залежність `CarInterface` (конструктор `AbstractTrip` її потребує) і також отримає з контейнера реалізацію `BMW` згідно з конфігурацією. Таким чином, `getCar()` поверне саме `BMW`. Метод `$car->getModel()` очікувано виведе "`BMW`".

Зміна конфігурації: якщо ми вирішимо, що для поїздок слід використовувати інший тип авто, достатньо оновити конфігурацію і, наприклад, прив’язати `CarInterface` до Audi:
```json
"singularity": {
    "preference": {
        ...
        "Foo\\Lifestyle\\Garage\\CarInterface": {
            "class": "Foo\\Lifestyle\\Garage\\Audi"
        }
    }
}```


Тоді без жодних змін у коді, лише завдяки оновленій конфігурації, поведінка зміниться:
```php
$trip = $singularity->get(Foo\Lifestyle\TripInterface::class);
$car = $trip->getCar();       // Тепер поверне Foo\Lifestyle\Garage\Audi
$model = $car->getModel();    // "Audi"
```

Таким чином, залежно від конфігурації ми отримуємо різні реалізації абстракції `CarInterface` – контейнер динамічно підставляє потрібний клас при створенні об’єкта. Це демонструє одну з ключових переваг DI-контейнера: розв’язність коду та можливість змінювати склад системи через зовнішні налаштування.

### Приклад використання в реальному застосунку

Уявімо тепер фрагмент більшої системи – наприклад, веб-застосунку, що працює з HTTP-запитами. Припустимо, ми реалізуємо обробник запиту (_PSR-15_ `RequestHandlerInterface`), котрий для формування відповіді потребує інформацію про поїздку. Ми можемо просто залежати від `TripInterface`, не турбуючись про те, яка саме реалізація буде використана:
```php
namespace Foo\Lifestyle\Weekend\Http;

use Foo\Lifestyle\TripInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\RequestHandlerInterface;

class HandleWeekendTripRequest implements RequestHandlerInterface
{
    public function __construct(
        private TripInterface $trip,
        // ... інші залежності (наприклад, репозиторії, сервіси тощо)
    ) {
        // Singularity DI сам розв'язує та впроваджує $trip 
        // згідно з конфігурацією (Weekend\Trip з залежністю CarInterface -> BMW/Audi)
    }

    protected function getTrip(): TripInterface
    {
        return $this->trip;
    }

    public function handle(ServerRequestInterface $request): ResponseInterface
    {
        $carModel = $this->getTrip()->getCar()->getModel();
        // $carModel буде "BMW" або "Audi" залежно від поточної конфігурації
        // ... формуємо відповідь HTTP на основі моделі авто чи інших даних
    }
}
```

Коли такий обробник буде створюватися контейнером (наприклад, у веб-фреймворку), `Singularity DI` побачить тип `TripInterface` у конструкторі. Він автоматично підставить реалізацію `Weekend\Trip` з усіма її залежностями. Якщо в конфігурації `CarInterface` зараз прив’язаний до `BMW`, `getCar()->getModel()` поверне "`BMW`"; якщо змінити прив’язку на `Audi` – отримаємо "`Audi`". Розробнику не потрібно змінювати код класу `HandleWeekendTripRequest` для вибору конкретної машини для поїздки – достатньо налаштувати це в конфігурації DI-контейнера.

Цей приклад ілюструє, як `Singularity DI` інтегрується у застосунок: всі залежності оголошуються у вигляді інтерфейсів у конструкторах, а контейнер у фоновому режимі вирішує, які конкретні реалізації підставити, враховуючи контекст і конфігурацію.

## Конфігурація

Налаштування `Singularity DI` здійснюється через конфігурацію, зазвичай це `JSON`-файл або `PHP`-структура, що містить вузол "`singularity`". Ця конфігурація може збиратися з декількох джерел (наприклад, із кожного встановленого пакету `Composer`, що надає свої налаштування). Структура конфігурації побудована таким чином, щоб охопити різні рівні прив’язок – глобальні, пакетні, контекстні. Нижче наведено спрощену схему (детальний `JSON`-schema можна знайти у файлі [singularity.schema.json](singularity.schema.json)):
```json
"singularity": {
    "preference": {
        // Глобальні прив'язки (highest priority)
        "Service\\Interface\\ID": {
            "class": "Concrete\\Implementation\\Class",
            "shared": true|false,                               // прапор "singleton' поведінки
            "weak": true|false                                  // використовується якщо shared=true  
            "arguments": {
                "<constructorArgName>": "...",                  // значення аргументу (примітив)
                "<constructorArgName>": {
                    "type": "service",
                    "preference": "<ServiceID or Class>"        // інша залежність (ідентифікатор сервісу)
                }
                // ...можна задавати всі аргументи конструктора за ім'ям
            },
            "plugins": {
                "<PluginClass>": false|<plugin-config-value>    // плагіни для цього сервісу: false = вимкнути, або конфіг для плагіна
            },
            "reference": "<path-to-reference-config>"           // посилання на заздалегідь визначену конфігурацію (для повторного використання)
        },
        // ...інші глобальні прив'язки
    },

    "namespace": {
        "Vendor\\Package\\Namespace\\": {
            "require": {
                "vendor/package-name": {},   // залежність на рівні пакету (composer package or group)
                // ...можливо декілька залежностей
            },
            "preference": {
                // Прив'язки для всього простору імен (пріоритет вище пакетного, але нижче глобального)
                "Another\\Service\\Interface": {
                    "class": "Concrete\\Class\\For\\Namespace"
                }
                // ...інші прив'язки для цього неймспейсу
            }
        },
        // ...конфігурація для інших namespace
    },

    "package": {
        "vendor/package-name": {
            "require": {
                "<vendor/other-dependency>": {}
                // ...залежності пакету, автоматично виявлені через composer
            }
        },
        "foo/lifestyle": {
            "preference": {
                "Foo\\Lifestyle\\Garage\\CarInterface": {
                    "class": "Foo\\Lifestyle\\Garage\\BMW"
                }
                // ...інші прив'язки пакету foo/lifestyle
            }
        },
        // ...конфігурації інших пакетів
    }
}
```

У цій структурі:

- `singularity.preference` – вузол для глобальних прив’язок. Тут можна явно перевизначити будь-який сервіс – ці налаштування мають найвищий пріоритет. Якщо сервіс зазначено тут, контейнер завжди візьме саме цю реалізацію (незалежно від того, що пропонують налаштування пакетів). Сюди ж можна додати специфічні аргументи чи плагіни для конкретного сервісу.

- `singularity.namespace` – вузол для налаштувань на рівні простору імен. Використовується для групування сервісів за логічними модулями/пакетами. Тут можна задати прив’язки, що стосуватимуться всіх сервісів під цим неймспейсом. Прив’язки, задані тут, мають вищий пріоритет, ніж пакетні, але нижчий, ніж глобальні.
    - а також зазначити, до якого пакету належить певний неймспейс (`require`).
     (Зазвичай він формується автоматично на основі конфігурацій, які надають встановлені Composer-пакети (через механізм `auto-discovery`))

- `singularity.package` – вузол для налаштувань, визначених самими пакетами. Ключ – ім’я пакету, значення – об’єкт з опціями, а також типові прив’язки (`preference`) для інтерфейсів, які він постачає. Ці налаштування є базовими або за замовчуванням.

    - `singularity.package.require` Пакет може оголосити свої залежності (`require`) на інші пакети. (Зазвичай він формується автоматично на основі конфігурацій, які надають встановлені Composer-пакети (через механізм `auto-discovery`)).

>Примітка: Завдяки пакету `conept-labs/config`, вузол `namespace` зазвичай генерується автоматично шляхом аналізу встановлених `Composer`-пакетів. Вам не потрібно вручну прописувати, який неймспейс до якого пакету належить – це робить плагін конфігурації, скануючи `PSR-4` автозавантаження та `concept.json` файли. Таким чином, контейнер може швидко визначити, з якого пакету походить запитуваний клас, і застосувати його налаштування. У вузлі `namespace` фактично задається прив’язка простору імен до пакету (на відміну від мапінгу у `composer`, де навпаки – пакет визначає свій неймспейс). Це прискорює резолюцію налаштувань і ізолює конфігурації різних модулів.

### Приклад контекстних прив’язок (`override` на рівні `namespace`):
Розглянемо випадок, коли потрібно, щоб різні сервіси мали різні реалізації однієї і тієї ж залежності. Наприклад, у нас є дві реалізації `TripInterface` – `Weekend\Trip` та `Workday\Trip`. Нехай поїздка вихідного дня вимагає машину `BMW`, а поїздка робочого дня – `Audi`. Глобальна прив’язка `CarInterface` -> `BMW` нам не підходить, адже вона однакова для всіх.

Одним із способів вирішити це є використання налаштувань простору імен. Припустимо, класи поїздок розділені по неймспейсах `Foo\Lifestyle\Weekend` і `Foo\Lifestyle\Workday`. Ми можемо додати в конфігурацію секцію `singularity.namespace`, де для кожного з цих неймспейсів вказати свою прив’язку `CarInterface`:
```json
"singularity": {
    ...
    "namespace": {
        "Foo\\Lifestyle\\Weekend\\": {
            "preference": {
                "Foo\\Lifestyle\\Garage\\CarInterface": {
                    "class": "Foo\\Lifestyle\\Garage\\BMW"
                }
            }
        },
        "Foo\\Lifestyle\\Workday\\": {
            "preference": {
                "Foo\\Lifestyle\\Garage\\CarInterface": {
                    "class": "Foo\\Lifestyle\\Garage\\Audi"
                }
            }
        }
    }
}
```

Згідно з цією конфігурацією:

- Для Weekend-поїздок (`Foo\Lifestyle\Weekend\Trip`) контейнер використовуватиме `BMW` при вирішенні залежності `CarInterface`.

- Для Workday-поїздок (`Foo\Lifestyle\Workday\Trip`) – `Audi`.

Отже, запити різних сервісів автоматично отримують різні реалізації спільної залежності, залежно від їх простору імен. Це і є прояв контекстної роботи DI-контейнера.

> Зауваження: хоча перевизначення на рівні `namespace` можливе, не рекомендується надмірно ним зловживати. У масштабних проєктах краще організувати конфігурацію через вузол `package` – тобто розбити код на логічні пакети, кожен з яких надає свої прив’язки за замовчуванням. Тоді різні модулі (пакети) самі визначатимуть свої реалізації, і потреба у `global` `namespace`-`override` зникне або мінімізується. При необхідності ж точкових змін використовуйте глобальний `preference` для конкретних сервісів.

Підсумовуючи, алгоритм резолюції в `Singularity DI` можна уявити так: коли ви викликаєте `$container->get(SomeInterface::class)`, контейнер:

- Дізнається, який пакет і неймспейс стосуються `SomeInterface`.

- Завантажує пакетні налаштування (типова реалізація, якщо є).

- Поверх них накладає перевизначення для простору імен (якщо задані).

- Поверх усіх – глобальні перевизначення для цього сервісу (якщо є).

- Створює об’єкт відповідно до отриманої конфігурації (або намагається автозаповнити, якщо нічого не було налаштовано).

## Фабрики (Factories)

Одним з принципів грамотної архітектури є уникнення прямого використання контейнера всередині бізнес-логіки – так званий антипатерн `Service Locator`. Замість того, щоб класи самостійно запитували залежності в контейнера, рекомендовано отримувати їх через конструктор (що ми і бачили в прикладі вище).

Однак іноді виникає потреба створювати нові екземпляри об’єктів на льоту, в середині методу, і зробити це через контейнер все ж хочеться (щоб скористатися всіма його перевагами, такими як автозаповнення). Для таких випадків `Singularity DI` надає спеціальну фабрику, яку можна інжектувати як залежність і викликати вже в коді.

Інтерфейс стандартної фабрики – `\Concept\Singularity\Factory\FactoryInterface` – доволі простий:
```php
namespace Concept\Singularity\Factory;

interface FactoryInterface
{
    /**
     * Створити екземпляр сервісу за його ідентифікатором.
     *
     * @param string $serviceId Ідентифікатор (клас або інтерфейс) сервісу
     * @param array $args Параметри, які потрібно передати в сервіс (необов'язково)
     * @return object Створений сервіс (об'єкт)
     */
    public function create(string $serviceId, array $args = []): object;
}
```

Ця фабрика є узагальненою: ви передаєте їй `ID` сервісу, а вона повертає створений об’єкт, користуючись тим самим контейнером «під капотом». При цьому можна додатково передати масив `$args` – вони будуть використані контейнером як явні аргументи при створенні (перекриваючи конфігурацію для конкретного виклику, якщо потрібно).

Для більш зручної та типобезпечної роботи можна визначати спеціалізовані фабрики для конкретних сервісів. `Singularity DI` пропонує базовий інтерфейс `ServiceFactoryInterface` для таких випадків:
```php
namespace Concept\Singularity\Factory;

interface ServiceFactoryInterface
{
    /**
     * Створити сервіс.
     * 
     * @param array $args Необов’язкові аргументи для створення.
     * @return object Створений сервіс.
     */
    public function create(array $args = []): object;
}
```

Спеціалізована фабрика знає наперед, який саме сервіс створює (або групу споріднених сервісів), тому метод `create()` тут не потребує явного `ID` – його реалізація захардкожена в самій фабриці. Зазвичай кожна така фабрика – клас, що імплементує `ServiceFactoryInterface` і прив’язаний до одного типу об’єктів.

Для зручності розробників Singularity надає абстрактний клас `Concept\Singularity\Factory\ServiceFactory`, який реалізує якраз такий базовий сценарій. В ньому вже зроблено всю роботу з виклику внутрішнього контейнера:
```php
namespace Concept\Singularity\Factory;

use Concept\Singularity\Context\ProtoContextInterface;
use Concept\Singularity\Contract\Lifecycle\SharedInterface;
use Concept\Singularity\SingularityInterface;

abstract class ServiceFactory implements ServiceFactoryInterface, SharedInterface
{
    public function __construct(
        private readonly SingularityInterface $container,
        private readonly ProtoContextInterface $context
    ) {}

    /**
     * Допоміжний метод для створення сервісу за ID 
     * (використовує внутрішній контейнер та зберігає контекст залежностей).
     */
    protected function createService(string $serviceId, array $args = []): object
    {
        // Отримуємо поточний стек залежностей і доповнюємо його своїм класом
        $depStack = $this->getContext()->getDependencyStack();
        array_unshift($depStack, static::class);
        
        // Викликаємо контейнер для створення сервісу в рамках оновленого контексту
        return $this->getContainer()->create($serviceId, $args, $depStack);
    }

    protected function getContainer(): SingularityInterface
    {
        return $this->container;
    }

    protected function getContext(): ProtoContextInterface
    {
        return $this->context;
    }
}
```

У конструктор такої фабрики автоматично інжектується сам DI-контейнер і `ProtoContext`. Зверніть увагу на параметр `ProtoContextInterface $context`: контейнер при створенні фабрики передає їй поточний контекст, у якому вона була створена. Це зроблено, щоб фабрика могла викликати інші сервіси через метод `createService()` і при цьому контейнер знав, що ці виклики відбуваються саме всередині цього контексту залежностей. По суті, стек залежностей `«заморожується»` на момент створення фабрики і доповнюється самою фабрикою – далі всі сервіси, які вона створює, “знають”, що були викликані через цю фабрику. Такий механізм допомагає уникнути проблем з циклічними залежностями та забезпечує правильну роботу плагінів у складних сценаріях.

### Приклад власної фабрики:
Припустимо, у нашому пакеті `foo/lifestyle` ми хочемо мати окрему фабрику саме для створення поїздок вихідного дня. Замість того, щоб у коді викликати універсальну `$factory->create(Foo\Lifestyle\TripInterface::class)`, ми можемо створити свій клас:
```php
namespace Foo\Lifestyle\Weekend;

class TripFactory extends \Concept\Singularity\Factory\ServiceFactory
{
    /**
     * Створити новий об'єкт Weekend\Trip.
     */
    public function create(array $args = []): object
    {
        // Використовуємо захищений метод createService, передаючи конкретний клас
        return $this->createService(\Foo\Lifestyle\Weekend\Trip::class, $args);
    }
}
```

Така фабрика може бути зареєстрована в контейнері як сервіс (в конфігурації просто нічого не потрібно – контейнер її створить автоматично через автозаповнення, оскільки вона залежить тільки від `SingularityInterface` і `ProtoContextInterface`, які він може надати). Тепер ми можемо інжектувати `TripFactory` у будь-який клас, що потребує динамічно створювати поїздки.

Наприклад, у контролері або сервісі бізнес-логіки:
```php
class SomeService
{
    public function __construct(private Foo\Lifestyle\Weekend\TripFactory $tripFactory) {}

    public function doSomething()
    {
        $trip = $this->tripFactory->create();
        $trip->drive();
        // "Driving <Car>" - де <Car> буде конкретною моделлю (BMW/Audi) за конфігурацією
    }
}
```


У цьому коді ми наочно уникаємо прямого виклику контейнера (`$singularity->get()` ніде не видно). Натомість ми отримуємо готову фабрику через `DI` та користуємося її методом `create()`. Всередині він все одно викликає контейнер, але це інкапсульовано. Зовні клас `SomeService` залежить від `TripFactory` – тобто добре зрозумілого інструменту, який явно створює `Trip`. Це підвищує читабельність і тестованість коду, а також дотримується принципу Inversion of Control більш строго.

Перевага стандартних фабрик: їх легко мокати або замінювати альтернативними реалізаціями при тестуванні. До того ж, ви можете розширювати логіку фабрики – наприклад, робити кешування результатів усередині неї, або передавати туди якісь спеціальні параметри без зміни сигнатури конструктора цільових класів.

## Порівняння з іншими DI-контейнерами

`Singularity DI` впроваджує ряд ідей, що вирізняють його на тлі класичних контейнерів залежностей у PHP. Ось декілька порівняльних моментів, які допоможуть зрозуміти особливості `Singularity DI`:

- Динамічні прив’язки vs статичні конфігурації: Багато контейнерів (наприклад, Symfony DI, PHP-DI) дозволяють визначати налаштування для сервісів, але зазвичай це або статичні YAML/XML/PHP-конфігурації, або атрибути/анотації в коді. Singularity же об’єднує конфігурації з різних джерел (пакети, простори імен, глобальні налаштування) автоматично і вибирає реалізацію залежно від контексту. Ви можете вказати різні реалізації інтерфейсу для різних модулів системи, не створюючи кілька контейнерів – достатньо налаштувати context-aware прив’язки.

- Плагіни (наскрізна логіка): У той час як інші DI-рішення можуть пропонувати “compiler passes” (Symfony) чи “definition decorators”, Singularity надає більш універсальний механізм плагінів, які виконуються під час роботи контейнера. Плагіни дозволяють змінювати поведінку створення на льоту: наприклад, умовно замінити об’єкт, реалізувати лениве завантаження через проксі, робити логування кожного створення сервісу і т.д. При цьому їх можна вмикати/вимикати конфігурацією. Такий рівень гнучкості рідко зустрічається в типових DI-контейнерах.

- Автовпровадження з підтримкою контексту: Більшість контейнерів підтримують автозаповнення залежностей за типом (глянемо хоча б PHP-DI або Laravel Container). Singularity теж це робить, але в комбінації з конфігураційним деревом. Це означає, що якщо з’являється кілька можливих реалізацій інтерфейсу, Singularity обере ту, що відповідає контексту (пакету/модулю) або глобальним налаштуванням. Інші контейнери часто вимагали б від розробника явно вказати бажану реалізацію в кожному місці або використовувати окремі контейнери на модуль.

К- ешування та збір сміття: Стандартні контейнері зазвичай зберігають створені сервіси протягом життєвого циклу програми (запиту) і не турбуються про їх видалення, оскільки типове застосування – HTTP-запит, який триває недовго. Але в довгоживучих процесах (демони, worker-и) такий підхід може спричиняти невиправдане споживання пам’яті. Singularity розв’язує це через WeakReference – він не утримує об’єкт, якщо той більше ніде не використовується. Інші популярні контейнері не мають такої можливості з коробки, тому розробник мусить сам слідкувати за видаленням невикористовуваних сервісів.

- Прототипи та нові екземпляри: У деяких DI-рішеннях можна налаштувати сервіс як “non-shared”, аби кожен get() створював новий об’єкт. Singularity ж дозволяє це зробити як через конфігурацію (реєструючи клас, що реалізує PrototypeInterface), так і у runtime – викликавши метод $container->create() можна примусово отримати новий об’єкт, навіть якщо сервіс зазвичай кешується. Це зручно, коли вам у конкретному випадку потрібна свіжа копія.

- Швидкість vs функціональність: Singularity надає додаткову гнучкість, але вона приходить з певною платою – більш складна логіка резолюції, рефлексії та виклику плагінів. Інші DI-контейнери (наприклад, Pimple або Symfony після компіляції контейнера) можуть працювати швидше завдяки простішій природі або попередній компіляції. Singularity ж розрахований більше на гнучкість та динамічність у великих системах. Однак, у типових сценаріях (веб-запити) його продуктивність залишається на прийнятному рівні, а переваги у зручності переважують потенційні втрати кількох мілісекунд.

Слід зауважити, що `Singularity DI` цілком дотримується контракту `PSR-11`, тож його можна використовувати там, де очікується стандартний контейнер. Але, скориставшись його розширеними можливостями, ви отримуєте більш «розумний» контейнер, здатний адаптуватися під ваш застосунок.

FAQ

Q: Для чого потрібен окремий метод create(), якщо є get()?
> A: Метод get() завжди намагається повернути один і той самий екземпляр сервісу (якщо він вже створений та кешований), дотримуючись принципу singleton за замовчуванням. create() же використовується, коли потрібно отримати новий екземпляр, незалежно від наявності кешу. Це буває корисно для сервісів із коротким життєвим циклом або коли ви хочете явно розділити об’єкти (наприклад, кілька різних підключень до бази даних одного класу). Після виклику create(), новостворений об’єкт також може бути закешований (як окремий, якщо він має власний ідентифікатор, або зовсім не кешується, якщо налаштовано weak reference).

Q: Як задати власні параметри для об’єкта при його створенні через контейнер?
> A: У конфігурації для прив’язки сервісу є секція "arguments", де можна вказати іменовані параметри конструктора та їх значення. Якщо ж потрібно передати параметри разово при виклику, використовуйте метод FactoryInterface->create($id, $args) – він приймає масив аргументів, які контейнер підставить у конструктор замість або на додачу до сконфігурованих.

Q: Що станеться, якщо два різні сервіси потребують одну й ту ж залежність, але з різними налаштуваннями?
> A: Singularity здатен врахувати контекст: якщо це різні сервіси (з різних пакетів чи просторів імен), ви можете задати для їх простору імен або конкретних ID різні прив’язки. Наприклад, як було показано, Weekend\Trip може отримати BMW, а Workday\Trip – Audi через налаштування namespace. Контейнер, знаючи який саме сервіс створює, застосує відповідне правило. Якщо ж обидва сервіси запитують той самий ID залежності в одному контексті, то вони отримають один і той же об’єкт (або новий, якщо це прототип) – тут розходжень не буде, оскільки правило одне. В разі потреби ізолювати їх, можна використати різні інтерфейси/токени для залежностей або різні контексти (наприклад, заводські методи, що створюють по одному на запит).

Q: Як додати або вимкнути плагін контейнера?
> A: Плагіни реєструються в конфігурації, в вузлі singularity.settings.plugin-manager.plugins. Ви додаєте запис з ключем – іменем класу плагіна, а значенням – налаштування (наприклад, пріоритет або false для вимкнення). Наприклад:
```json
"singularity": {
  "settings": {
    "plugin-manager": {
      "plugins": {
        "Acme\\Singularity\\Plugin\\LogPlugin": { "priority": 100 },
        "Acme\\Singularity\\Plugin\\CachePlugin": false
      }
    }
  }
}
```

Це підключить LogPlugin з пріоритетом 100 і вимкне CachePlugin. Крім того, для конкретного сервісу можна в його прив’язці (plugins секція) окремо вимкнути той чи інший плагін або передати йому специфічні дані. У коді ж вручну нічого викликати не потрібно – менеджер плагінів усе зробить автоматично при створенні сервісу.

Q: Чи можна використати Singularity DI у фреймворку X або проекті Y?
> A: Так. Singularity дотримується PSR-11, тому будь-де, де очікується Psr\Container\ContainerInterface, ви можете підставити Singularity. Наприклад, у Mezzio чи Slim можна замінити дефолтний контейнер на Singularity, щоб скористатися його можливостями. В екосистемі Concept Labs Singularity використовується за замовчуванням, але це не прив’язує його до якогось конкретного фреймворку. Головне – забезпечити завантаження конфігурації (через Concept Labs Config або власноруч) перед тим, як ви почнете запитувати сервіси.

Q: Яка версія PHP потрібна для Singularity DI?
> A: Singularity розроблено з використанням сучасних можливостей PHP, тому вимагає PHP 8.0 або вище. Зокрема, він використовує типізовані властивості в конструкторах, WeakReference (з’явився в PHP 7.4) та атрибути (PHP 8.0+). Рекомендується актуальна версія PHP для найкращої продуктивності та повної підтримки функціоналу.

Q: Як відлагоджувати або візуалізувати процес резолюції залежностей?
> A: Для налагодження Singularity надає інформацію у винятках (наприклад, ServiceNotFoundException містить шлях залежностей, по якому контейнер намагався знайти сервіс). Також ви можете увімкнути спеціальний debug-плагін, який буде логувати кожен крок створення сервісу (до/після, який клас створено, скільки часу зайняло тощо). Оскільки Singularity – це бібліотека, конкретна реалізація логування залежить від інтеграції: в екосистемі Concept є стандартні плагіни для профілювання. В крайньому випадку, можна тимчасово вставити свій плагін з високим пріоритетом, який буде друкувати або збирати потрібну інформацію з ProtoContext.

Q: Чи підтримує Singularity “lazy loading” сервісів?
> A: Безпосередньо контейнер створює сервіси одразу при запиті (get()), тобто не відкладає їх до моменту першого використання – сам факт виклику get() і є запитом використання. Однак, реалізувати ледачу ініціалізацію можна через плагіни: наприклад, плагін може обгорнути об’єкт у проксі (який відкладає виконання певних методів до звернення) або взагалі відкласти створення, повернувши проксі-об’єкт замість реального. Такі механізми можна додати, написавши власний плагін. Вбудованої ленивої ініціалізації “з коробки” Singularity не має, але його гнучкість дозволяє інтегрувати цю можливість при потребі.