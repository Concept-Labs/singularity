Singularity PSR-11 Container

Singularity – це next-gen контейнер залежностей (DI, Dependency Injection) для PHP, що відповідає стандарту PSR-11. Він дозволяє керувати створенням сервісів залежно від контексту їх запиту. Контейнер Singularity налаштовується через конфігурацію, яку зазвичай збирає пакет concept-labs/config. Цей конфігураційний менеджер автоматично об’єднує конфігурації різних пакетів (використовуючи плагін аналізу Composer-пакетів) і будує цілісну конфігурацію для контейнера. Нижче описано структуру такої конфігурації та плагінову систему Singularity.

Конфігурація на рівні пакета (singularity.package)

Конфігурація Singularity організована ієрархічно. Вона складається з трьох основних рівнів: глобальні налаштування (top-level), на рівні простору імен (namespace-level) та на рівні пакета (package-level). Така архітектура дозволяє гнучко визначати залежності і перевизначати їх на різних рівнях. Найвищий пріоритет мають глобальні налаштування, потім налаштування простору імен, і останнім застосовується конфігурація пакета.

Ключові вузли конфігурації в JSON виглядають так:

singularity.preference – глобальні прив’язки інтерфейсів/ідентифікаторів до класів (мають найвищий пріоритет і перекривають інші рівні).

singularity.namespace – конфігурація для окремих просторів імен. Зазвичай генерується автоматично на основі встановлених Composer-пакетів, але може бути задана вручну. Включає:

require – визначає, які пакети необхідно підключити при зверненні до сервісів у цьому просторі імен.

preference – прив’язки (як і на глобальному рівні) для всіх сервісів у цьому просторі імен (перекривають пакетні).

singularity.package – конфігурація конкретних пакетів (зазвичай відповідає назвам Composer-пакетів). Тут пакети декларують свої залежності та прив’язки за замовчуванням:

require – список інших пакетів, які необхідно підключити перед цим пакетом (зазвичай – залежності пакета).

preference – прив’язки інтерфейсів до реалізацій, які цей пакет надає або використовує за замовчуванням.

Нижче наведено повний приклад конфігурації з акцентом на вузол singularity.package. Уявімо, що є два пакети: concept-labs/dbc (бібліотека для роботи з базою даних, що надає інтерфейс з’єднання) і concept-labs/dbal (більш високорівневий пакет, що залежить від DBC). Пакет DBC містить ConnectionInterface і реалізацію Connection. Пакет DBAL, наприклад, надає клас QueryManager, який потребує ConnectionInterface. Ми також покажемо, як застосувати власну реалізацію інтерфейсу через конфігурацію.

{
  "singularity": {
    "package": {
      "concept-labs/dbc": {
        "preference": {
          "Concept\\DBC\\ConnectionInterface": {
            "class": "Concept\\DBC\\Connection",
            "arguments": {
              "dsn": "<dsn-string>",
              "user": "<user>",
              "password": "<password>"
            }
          }
        }
      },
      "concept-labs/dbal": {
        "require": {
          "concept-labs/dbc": {}
        },
        "preference": {
          "Concept\\DBAL\\QueryManager": {
            "class": "Concept\\DBAL\\QueryManager"
            // Припустимо, QueryManager у конструкторі потребує ConnectionInterface
            // Контейнер сам підставить реалізацію з пакета DBC
          }
        }
      }
    },
    "namespace": {
      "Concept\\DBC\\": {
        "require": {
          "concept-labs/dbc": {}
        }
      },
      "Concept\\DBAL\\": {
        "require": {
          "concept-labs/dbal": {}
        }
      }
    },
    "preference": {
      // Глобальні перевизначення (якщо потрібно)
      // Наприклад, перевизначимо реалізацію ConnectionInterface своєю власною:
      "Concept\\DBC\\ConnectionInterface": {
        "class": "MyApp\\DB\\Connection", 
        "arguments": { /* ... */ }
      }
    }
  }
}


У наведеній конфігурації:

Пакет concept-labs/dbc в блоці preference прив’язує інтерфейс Concept\DBC\ConnectionInterface до свого стандартного класу Concept\DBC\Connection (із вказанням аргументів підключення до БД). Таким чином, за замовчуванням, будь-який сервіс, що залежить від ConnectionInterface, отримає саме Connection.

Пакет concept-labs/dbal вказує в блоці require, що перед його використанням потрібно підключити конфігурацію пакета concept-labs/dbc. Це означає, що коли контейнеру знадобиться створити сервіс із простору імен Concept\DBAL\..., він спочатку завантажить конфігурацію DBC. У блоці preference пакета DBAL ми могли б задати власні прив’язки, але в даному випадку для спрощення показано лише, що сам клас QueryManager знаходиться в цьому пакеті (як правило, достатньо вказати class без інтерфейсу, щоб контейнер знав, як його створити).

У вузлі singularity.namespace оголошено відповідність між просторами імен і пакетами: всі сервіси, що починаються з Concept\DBC\ будуть вимагати завантаження пакета concept-labs/dbc, а сервіси з Concept\DBAL\ – пакета concept-labs/dbal. Ці вузли, як правило, генеруються автоматично плагіном конфігурації на основі інформації Composer (назви пакета і його базового неймспейсу). Розробнику зазвичай не потрібно вручну писати ці відповідності – достатньо налаштувати конфігурацію пакета, а система composer-discovery зробить решту. (В разі потреби, це можна зробити й вручну, як показано вище).

У глобальному блоці singularity.preference ми продемонстрували перевизначення: навіть якщо пакет DBC за замовчуванням прив’язує ConnectionInterface до Concept\DBC\Connection, розробник може замінити реалізацію на свою (наприклад, MyApp\DB\Connection). Через те, що глобальний рівень має найвищий пріоритет, контейнер використає клас MyApp\DB\Connection замість стандартного, не змінюючи при цьому конфігурацій пакетів.

Архітектура цього підходу забезпечує модульність і гнучкість:

Кожен пакет інкапсулює свою конфігурацію DI (власні прив’язки і залежності) у блоці singularity.package. Це спрощує повторне використання пакетів: підключаючи новий пакет, ви отримуєте його типові налаштування залежностей автоматично.

Декларація require на рівні пакета визначає контекстні залежності: коли потрібен сервіс із певного пакета, контейнер знає, які інші конфігурації повинні бути застосовані раніше. Це нагадує залежності між модулями: наприклад, якщо ModuleA потребує ModuleB, то DI-контейнер спершу завантажить налаштування ModuleB. У прикладі, пакет DBAL вимагає DBC, тому всі прив’язки DBC будуть доступні до створення сервісів DBAL.

Розробник може перекривати реалізації на рівні додатку (глобально або для окремого простору імен). Наприклад, якщо якась бібліотека пропонує за замовчуванням клас X для інтерфейсу Y, ви можете замінити його своїм, не змінюючи код бібліотеки – достатньо в конфігурації задати відповідний binding на вищому рівні.

Контейнер Singularity під час виклику ->get() визначає, до якого простору імен належить запитуваний сервіс, та динамічно підключає необхідні пакети (через конфігурацію). Завдяки цьому не потрібно завантажувати повну конфігурацію всіх пакетів наперед – лише те, що необхідно в контексті поточного запиту. Це підвищує продуктивність і дозволяє легко масштабувати систему із багатьох незалежних модулів.

Приклад використання: після налаштування конфігурації, отримання сервісів з контейнера виглядає так само просто, як і в звичайному DI-контейнері, але під капотом працює вказана логіка вибору реалізацій:

use Concept\Singularity\Singularity;

/** @var Singularity $container */
// Припустимо, $container вже створений і сконфігурований об'єктом ConfigInterface

// Отримуємо об'єкт з пакета DBAL, який залежить від DBC:
$queryManager = $container->get(\Concept\DBAL\QueryManager::class);
// Контейнер автоматично підхопить конфігурацію concept-labs/dbc, 
// створить Connection (або MyApp\DB\Connection, якщо перевизначено) 
// і передасть його в конструктор QueryManager.


В наведеному прикладі виклик $container->get(QueryManager::class) ініціює такий процес:

Визначення контексту: Контейнер бачить, що клас Concept\DBAL\QueryManager належить простору імен Concept\DBAL\. Згідно з конфігурацією singularity.namespace, це відповідає пакету concept-labs/dbal.

Завантаження залежностей пакета: Перед створенням QueryManager, контейнер завантажує конфігурацію пакета DBAL. В конфігурації зазначено require: { "concept-labs/dbc": {} }, тож спершу буде застосовано конфігурацію DBC (якщо вона ще не була застосована).

Вибір реалізацій: Тепер контейнер знає, що для інтерфейсу ConnectionInterface (який потрібен QueryManager у конструкторі) у пакета DBC задано клас Concept\DBC\Connection. Якщо у глобальній чи namespace-конфігурації немає перевизначень, буде використано саме його.

Створення об’єктів: Контейнер рекурсивно створює усі залежності. Спочатку він створить об’єкт Concept\DBC\Connection для ConnectionInterface (підставивши потрібні параметри, наприклад, рядок з’єднання), потім – екземпляр Concept\DBAL\QueryManager, передавши в його конструктор створений Connection.

Результат: На виході ви отримуєте готовий об’єкт QueryManager з усіма вкладеними залежностями, сконструйований згідно з правилами, заданими в конфігурації. Якщо пізніше ви викличете $container->get(ConnectionInterface::class) або $container->get('Concept\DBC\Connection'), то за замовчуванням контейнер поверне той самий екземпляр з'єднання (оскільки він позначений як shared за умовчанням – див. нижче про SharedPlugin).

Таким чином, singularity.package конфігурація дозволяє інкапсулювати взаємопов’язані визначення сервісів на рівні пакету і автоматично враховувати залежності між пакетами. Розробник може мислити категоріями модулів: кожен модуль постачає певні сервіси і потребує певні сервіси – контейнер подбає про збирання цього всього разом.

Плагінова система

Singularity має вбудовану плагінову систему, яка дає змогу розширювати поведінку контейнера при створенні сервісів. Плагіни можуть виконувати додаткові дії до створення об’єкта сервісу або після цього, інтегруючись у життєвий цикл get() запиту. Це дозволяє реалізувати такі можливості, як: одиночність або прототипність сервісів (singleton/prototype), автовиклик методів ініціалізації, підтримка PHP-атрибутів для впровадження залежностей, ліниве створення об’єктів тощо – без зміни основної логіки контейнера. Нижче детально розглянемо інтерфейс плагінів, механіку їх підключення та використання, а також наявні “з коробки” плагіни Singularity.

Інтерфейс PluginInterface

Кожен плагін у Singularity реалізує інтерфейс PluginInterface. Він визначає два статичних методи – before(...) і after(...), які виконуються відповідно до створення сервісу і після створення сервісу. Сигнатура інтерфейсу наступна:

interface PluginInterface 
{
    const BEFORE = 'before';
    const AFTER = 'after';

    public static function before(\Concept\Singularity\Context\ProtoContextInterface $context, mixed $args = null): void;

    public static function after(object $service, \Concept\Singularity\Context\ProtoContextInterface $context, mixed $args = null): void;
}


Метод before(...) отримує контекст створення сервісу (об’єкт, що реалізує ProtoContextInterface) та опціональні аргументи, і виконується перед тим, як контейнер почне безпосередньо створювати об’єкт. Метод after(...), натомість, викликається після того, як об’єкт сервісу вже створений; він отримує цей створений об’єкт та той самий контекст. Обидва методи є статичними, оскільки плагіни в Singularity не потребують зберігати стан між викликами – кожен виклик здійснюється з усією необхідною інформацією через параметри.

ProtoContextInterface – це інтерфейс, що представляє контекст поточного запиту сервісу. Через об’єкт контексту плагін може дізнатися:

ID сервісу, який запитується (getServiceId()),

Повністю визначений клас, який буде створюватися (getServiceClass() – з урахуванням preference та інших налаштувань контейнера),

Відображення для рефлексії (getReflection() – об’єкт ReflectionClass для сервісу),

Аргументи, передані до контейнера для створення (якщо були),

Контейнер, що створює сервіс (getContainer()),

А також іншу інформацію (наприклад, стек залежностей для відслідковування циклічних посилань, тощо).

Інтерфейс PluginInterface надає базовий контракт. Для спрощення розробки плагінів у Singularity передбачено абстрактний клас AbstractPlugin, який вже реалізує цей інтерфейс (пустими методами). Створюючи новий плагін, можна успадкуватися від AbstractPlugin і перевизначити лише ті методи (before або after), які необхідно реалізувати. Це позбавляє від потреби оголошувати обидва методи, якщо, наприклад, плагін має дію тільки «після» створення сервісу.

Інтеграція плагінів у процес створення сервісів

Плагіни інтегруються в роботу контейнера через спеціальний менеджер плагінів. Plugin Manager збирає зареєстровані плагіни та викликає їхні методи before/after у потрібний момент. Коли ви викликаєте $container->get(<ServiceId>), Singularity виконує наступне:

Before-phase: Безпосередньо перед створенням нового об’єкта контейнер викликає PluginManager->before($context, PluginInterface::class). Менеджер плагінів проходить по всіх зареєстрованих плагінах і викликає їх статичні методи before($context, $args). Таким чином, всі підключені плагіни мають шанс втрутитися в процес до того, як об’єкт буде побудовано. Плагін може проаналізувати запит (контекст) і, за потреби, внести корективи. Наприклад, FactoryPlugin на цьому етапі може замінити фабрику створення сервісу (про це нижче), або плагін може змінити деякі аргументи контексту, увімкнути/вимкнути інші плагіни для цього сервісу тощо.

Створення сервісу: Після виклику before-методів контейнер продовжує стандартне створення сервісу. Зазвичай, якщо фабрику не було змінено плагінами, Singularity просто викликає конструктор класу (new <ServiceClass>(...)) з усіма зібраними залежностями. (В процесі резолвінгу залежностей можуть рекурсивно викликатися get() для інших сервісів, які, у свою чергу, також пройдуть через плагіни – це забезпечує єдиний механізм для всіх рівнів залежностей).

After-phase: Одразу після того, як об’єкт сервісу створено, контейнер викликає PluginManager->after($service, $context, PluginInterface::class). Менеджер плагінів знов проходиться по всіх плагінах і викликає їх after($service, $context, $args). На цьому етапі плагіни можуть виконувати пост-обробку об’єкта – наприклад, здійснити додаткову ініціалізацію, зареєструвати об’єкт для подальшого повторного використання, обгорнути його проксі-об’єктом для лінивого завантаження, або викликати якісь методи життєвого циклу сервісу.

Важливо, що послідовність виконання плагінів може бути налаштована. Кожен плагін при реєстрації отримує пріоритет (за замовчуванням всі плагіни можуть мати пріоритет 0, або ви можете задати інше значення). Plugin Manager впорядковує виклик before/after відповідно до пріоритетів: плагіни з меншим значенням пріоритету виконуються раніше, з більшим – пізніше. Це дозволяє тонко налаштувати, в якій послідовності різні плагіни будуть впливати на процес створення сервісу.

Налаштування та підключення плагінів

За замовчуванням Singularity має набір вбудованих плагінів (про них далі), але ви можете додавати власні плагіни. Реєстрація плагіна зазвичай здійснюється через конфігурацію. У конфігурації передбачений вузол singularity.settings.plugin-manager.plugins, де можна перелічити додаткові плагіни. Наприклад:

"singularity": {
  "settings": {
    "plugin-manager": {
      "plugins": {
        "0": {
          "MyApp\\DI\\Plugin\\LoggingPlugin": null
        },
        "10": {
          "Another\\Plugin\\CustomPlugin": { "option": true }
        }
      }
    }
  }
}


У такому прикладі налаштовано два плагіни:

MyApp\DI\Plugin\LoggingPlugin з пріоритетом 0 (виконуватиметься першим). Значення null вказує, що для цього плагіна немає додаткових параметрів конфігурації.

Another\Plugin\CustomPlugin з пріоритетом 10 (виконуватиметься після LoggingPlugin). Для нього передано приклад додаткової опції option: true (у загальному випадку, args — це масив або скаляр, який буде другим параметром у методах before/after плагіна).

Примітка: Ключі (напр. "0", "10") слугують для впорядкування. Ви можете використовувати будь-які числові значення для позначення пріоритетів плагінів. Якщо кілька плагінів мають однаковий пріоритет, їх порядок визначається або додатковою логікою менеджера, або вони можуть виконуватись у довільному порядку – тому пріоритети бажано робити унікальними, відступаючи між ними (наприклад, 0, 10, 20, ...), щоб було легше вставляти нові.

Коли конфігурація застосовується до контейнера (це відбувається при ініціалізації Singularity через метод ->setConfig(...)), менеджер плагінів зчитує цей список і реєструє відповідні плагін-класи. Після цього вони автоматично починають брати участь у життєвому циклі створення сервісів.

Створення власного плагіну (приклад)

Розглянемо простий приклад створення користувацького плагіну. Припустимо, ми хочемо логувати інформацію про кожен створюваний сервіс. Для цього створимо плагін LoggingPlugin, який перед створенням і після створення сервісу записує повідомлення в лог.

namespace MyApp\DI\Plugin;

use Concept\Singularity\Plugin\AbstractPlugin;
use Concept\Singularity\Context\ProtoContextInterface;

class LoggingPlugin extends AbstractPlugin 
{
    public static function before(ProtoContextInterface $context, mixed $args = null): void
    {
        $serviceId = $context->getServiceId();
        error_log("[Singularity] Creating service: $serviceId");
    }

    public static function after(object $service, ProtoContextInterface $context, mixed $args = null): void
    {
        $serviceClass = get_class($service);
        error_log("[Singularity] Service created: $serviceClass");
    }
}


Кілька пояснень до цього прикладу:

Ми успадкували LoggingPlugin від AbstractPlugin, щоб не прописувати методи, які не використовуємо (в даному випадку ми реалізуємо і before, і after, але якби, наприклад, нам потрібен був тільки метод after, before можна було б не перевизначати – успадкований пустий метод просто нічого не робив би).

У методі before ми отримуємо ID сервісу, який буде створюватися, через $context->getServiceId() і логуємо це. (ID може бути ім’ям класу або аліасом, залежно від того, що передавалося в ->get()).

У методі after ми отримуємо вже створений об’єкт $service і визначаємо його клас, щоб залогувати повідомлення про успішне створення. Тут також можна отримати ID або інші деталі з $context при потребі.

Після написання такого класу, слід додати його до конфігурації (як показано вище) в список плагінів. Наприклад:

"singularity": {
  "settings": {
    "plugin-manager": {
      "plugins": {
        "0": {
          "MyApp\\DI\\Plugin\\LoggingPlugin": null
        }
      }
    }
  }
}


Тепер Singularity при кожному створенні будь-якого сервісу буде викликати наш LoggingPlugin, і в логах з’являтимуться записи про те, які сервіси створюються.

Звісно, цей приклад доволі простий. За допомогою плагінів можна робити і складніші речі – наприклад, умовно включати/виключати інші плагіни, модифікувати способи створення сервісів, або навіть повністю перехоплювати створення певних об’єктів. Головне – пам’ятати, що плагіни не повинні зловживати своїми можливостями (наприклад, не варто в плагіні без потреби викликати створення інших сервісів, щоб не виникало непередбачуваних залежностей). Але в цілому, плагінова система – потужний інструмент для розширення функціональності DI-контейнера.

Вбудовані плагіни Singularity

З коробки Singularity постачається з декількома стандартними плагінами, які забезпечують базові можливості контейнера. Нижче перелік основних плагінів та опис їх функцій:

SharedPlugin (плагін управління спільними сервісами): Забезпечує singleton-поведінку за замовчуванням. Коли сервіс створюється, цей плагін (через свою реалізацію after) автоматично реєструє створений об’єкт в контейнері, щоб при наступних запитах того самого сервісу повертати вже існуючий екземпляр замість створення нового. Іншими словами, якщо сервіс позначений як «shared» (а за замовчуванням всі сервіси вважаються спільними, якщо не вказано протилежне), то після першого створення він зберігається і повторно використовується. У конфігурації можна явно керувати цим: наприклад, встановивши для конкретного binding параметр "shared": false, можна відключити кешування, і тоді SharedPlugin пропустить реєстрацію – контейнер щоразу створюватиме новий об’єкт. Також підтримується режим weak для спільних сервісів (наприклад, зберігання слабких посилань замість прямих, щоб уникнути витоку пам’яті у певних сценаріях), який теж налаштовується через параметри. Плагін Shared гарантує, що якщо сервіс має бути єдиним, у контейнері він теж буде єдиним.

PrototypePlugin (плагін управління прототипами): Доповнює SharedPlugin, забезпечуючи prototype-поведінку сервісів, які цього потребують. Якщо сервіс позначено як прототипний (на відміну від singleton), контейнер має створювати новий екземпляр при кожному запиті. В Singularity це реалізовано через контракт PrototypeInterface. Якщо клас сервісу реалізує Concept\Singularity\Contract\Lifecycle\PrototypeInterface, він повинен надати метод prototype(), який повертає новий екземпляр (наприклад, клон або новостворений об’єкт). PrototypePlugin після створення об’єкта перевіряє, чи він реалізує PrototypeInterface. Якщо так – контейнер не зберігає його як shared (або може зберегти лише базовий екземпляр), а при наступних зверненнях може викликати метод prototype() для отримання копії. Якщо ж сервіс очікувався як прототипний (наприклад, у конфігурації для нього стоїть "shared": false або інший сигнал), а клас не реалізує потрібний інтерфейс, плагін може кинути виняток, сигналізуючи про порушення контракту. Таким чином, PrototypePlugin забезпечує, що сервіси, які повинні бути множинними, не кешуються і, за можливості, надають нові екземпляри оптимальним шляхом.

AttributePlugin (плагін підтримки атрибутів): Включає механізми для роботи з PHP-атрибутами у контексті DI. Він дозволяє налаштовувати поведінку для окремих класів через PHP 8 атрибути. Зокрема, Singularity має вбудовані атрибути #[\Concept\Singularity\Plugin\Attribute\Plugin] та #[\Concept\Singularity\Plugin\Attribute\Injector]. Як це працює: якщо клас сервісу позначений атрибутом #[Plugin(SomePlugin::class, args)], AttributePlugin при створенні такого сервісу викличе додатковий плагін SomePlugin тільки для цього класу. Це дає змогу “прикріпити” певний плагін до конкретного сервісу через анотацію в коді, навіть не додаючи його глобально в Plugin Manager. Наприклад, ви можете помітити якийсь клас атрибутом, що вказує на плагін логування або спеціальної ініціалізації – і цей плагін буде виконано тільки для цього сервісу. Атрибут Injector використовується для позначення методів, які потрібно викликати для впровадження залежностей після створення об’єкта (щось подібне до post-construct методів). Плагін Attribute сканує клас та його методи на наявність таких атрибутів і відповідним чином реагує: викликає зазначені методи, або підключає зазначені в атрибутах плагіни в процес before/after саме для цього об’єкта. Таким чином, AttributePlugin забезпечує гнучку, декларативну конфігурацію DI прямо в коді класів за допомогою сучасного механізму атрибутів PHP.

FactoryPlugin (плагін фабрик/ліниве завантаження): Дозволяє тонко налаштувати, як створюється об’єкт сервісу. У стандартному режимі контейнер просто викликає конструктор класу. FactoryPlugin же може перехопити цей момент (на фазі before) і встановити для поточного контексту спеціальну фабрику створення. Наприклад, є два типових сценарії:

Lazy Initialization (ліниве створення): Клас може реалізовувати певний інтерфейс або бути проксі-обгорткою, яка відкладає створення “важкого” об’єкта до першого виклику методу. FactoryPlugin може виявити, що запитуваний сервіс – це lazy proxy (приміром, клас, який має в назві Lazy або реалізує спеціальний інтерфейс), і замість створення реального об’єкта одразу, підставити фабрику, яка при першому зверненні виконає фактичне створення. Таким чином контейнер поверне легку обгортку, а важкий об’єкт створиться тільки при потребі.

Custom Factory: Іноді буває, що об’єкт потрібно створити не через прямий виклик конструктора, а через фабричний метод або фабричний сервіс. FactoryPlugin може надати підтримку такого патерну. Наприклад, якщо в конфігурації для сервісу вказано не ключ "class", а щось на кшталт "factory": [<FactoryClass>, "<method>"], плагін Factory може перехопити before і встановити фабрику, яка викличе цей метод фабрики для отримання об’єкта.

Завжди новий екземпляр: У випадках, коли потрібно завжди створювати новий екземпляр незалежно від того, чи збережений старий (аналог прототипу), FactoryPlugin може встановити фабрику, яка завжди робить new ... (по суті, дублюючи поведінку прототипу, але це може бути корисно для примусової ізоляції або тестування).

Реалізацій FactoryPlugin у Singularity декілька: є, зокрема, підплагіни LazyGhost і NewInstance, які відповідають за різні аспекти. Але з точки зору користувача контейнера важливо розуміти загальне: FactoryPlugin дає можливість змінити спосіб створення об’єкта. У більшості випадків вам не треба безпосередньо налаштовувати цей плагін – він працює автоматично, реагуючи на певні шаблони конфігурації або інтерфейси. Але знання про нього допоможе зрозуміти, як реалізовані ліниві сервіси чи альтернативні способи інстанціювання об’єктів у контейнері.

Перераховані плагіни активуються автоматично, якщо їхні умови виконуються:

Сервіси за замовчуванням створюються як shared (керує SharedPlugin). Якщо потрібно змінити це для конкретного сервісу – ви вказуєте опцію, і тоді або SharedPlugin не зареєструє його, або PrototypePlugin забезпечить клонування.

Якщо клас сервісу реалізує контракти життєвого циклу (SharedInterface або PrototypeInterface), відповідні плагіни контролюють дотримання цього (наприклад, якщо клас заявив себе як Prototype, але ви спробували зберегти його як shared – виникне помилка).

Якщо ви використовуєте атрибути Singularity у своєму коді, AttributePlugin автоматично обробить їх.

Більшість поведінки factory/lazy вмонтовані так, що користувачу достатньо вказати потрібну конфігурацію (наприклад, factory в конфігурації, або використати спеціальний проксі-клас), а FactoryPlugin зробить решту.

Завдяки плагіновій системі, контейнер Singularity залишається легким у використанні для базових випадків, але надзвичайно гнучким для розширених сценаріїв. Ви можете додавати свої плагіни для нових видів поведінки або використовувати наявні, майже не втручаючись у основний код вашого додатку – достатньо налаштувати конфігурацію або анотації. Докладніше про розширення Singularity і розробку власних плагінів ви можете дізнатися з прикладів та вихідного коду, але сподіваємося, що цей огляд дав чітке розуміння ключових можливостей. Вдалого використання Singularity DI!